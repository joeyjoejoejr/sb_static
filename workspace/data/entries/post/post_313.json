{
  "id": "post_313",
  "Title": "Next Generation Web Framework",
  "Summary": "Having been excited about Ruby on Rails since just after its 1.0 release back in late 2005, it’s hard to imagine life without it. Whenever I come across a tangled knot of PHP or a Java beast my first response is “I wish this was Rails.” But by around 2010 there arose a potential challenger:…",
  "Body": "<p>\r\n\tHaving been excited about Ruby on Rails since just after its 1.0 release back in late 2005, it’s hard to imagine life without it. Whenever I come across a tangled knot of PHP or a Java beast my first response is “I wish this was Rails.” But by around 2010 there arose a potential challenger:</p><h3>Node.js</h3><p>\r\n\tWhen I first understood the benefits of asynchronous, event-driven flow I was really excited. It made perfect sense with analogies like the \r\n\t<a href=\"http://code.danyork.com/2011/01/25/node-js-doctors-offices-and-fast-food-restaurants-understanding-event-driven-programming/\">fast food restaurant</a>. So I got Node running and my first impression was “wow, this is so much faster than Rails; I need to think about refactoring all my apps into Node”. But it didn’t take long to realize that wasn’t going to work. Node.js was missing lots of the things I took for granted with Rails. Things like form helpers and <a href=\"http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">MVC architecture</a>. Now I’m sure lots of people can respond with “Node’s got those–look at X, Y and Z!” I’ve tried <a href=\"http://expressjs.com/\">Express</a> and even <a href=\"http://railwayjs.com/\">Railway</a>. None of them seemed to just get things right the way Rails does. Rails is opinionated software that makes a lot of choices from the start. Not all of those choices are going to be correct, but there’s nearly always a way to change the defaults. Moreover, all other things being equal, I’m on the <a href=\"http://37signals.com/svn/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui\" target=\"_blank\">side of DHH</a> on preferring to code in Ruby over Javascript.</p><h3>Drawbacks to Rails</h3><p>\r\n\tRails is getting faster and more powerful all the time, but it’s start up time is still quite slow. Its response time would benefit greatly if it used an asynchronous, event driven architecture, but that would require rewriting the entire framework and all its libraries–never a good idea. You’d lose all the synchronous advantages like simplicity of code, no need for callbacks, sequential execution, and ease of debugging.</p><h3>Faye to the Rescue</h3><p>\r\n\tSo how can we have our cake and eat it? \r\n\t<a href=\"http://faye.jcoglan.com/\">Faye</a> uses the powerful <a href=\"http://rubyeventmachine.com/\">EventMachine library</a> to bring event processing to Ruby. It wasn’t hard to integrate with Ruby, especially thanks to Ryan Bates’ handy <a href=\"https://github.com/ryanb/private_pub/\">PrivatePub</a> (<a href=\"http://railscasts.com/episodes/316-private-pub\">Railscast</a>). So now we have both synchronous and asynchronous I/O living in the same app. How does this help? Forms and views can be written in the standard Rails way and server push notifications can be sent out at any time. Client events can trigger Rails actions that notify other clients of the changes à la <a href=\"https://github.com/Flotype/now\">NowJS</a>.</p><h3>Other Options</h3><p>\r\n\tOther than Rails and Node, there are a few notable frameworks in other languages. Erlang is a good language choice because of its concurrency and making asynchronous development easier. \r\n\t<a href=\"http://www.chicagoboss.org/\">Chicago Boss</a> and <a href=\"http://nitrogenproject.com/\">Nitrogen</a> both look like promising frameworks written in Erlang. Haskel enforces strict typing and automatically executes in a non-blocking manner and boasts the <a href=\"http://www.yesodweb.com/\">Yesod</a> web framework. Choosing these or other less mainstream languages may or may not pan out well depending on your organization’s willingness to try new things.</p><h3>The Future</h3><p>\r\n\tSo what will the next generation of web frameworks be like? I don’t see a clear winner here. Rails is excellent at building RESTful services and Node works great for client-heavy web apps. Rails’ features will gradually get ported over to Node through packages such as Express and Railway. Node will influence Rails developers to consider event-driven architecture where they need it, such as push notifications and multi-user collaboration. Other languages will exert their influence and perhaps produce formidable challengers to Rails and Node. From a user’s perspective a non-blocking asynchronous application seems faster as the UI can continue to accept input even while performing tasks on the server. So I do hope to see more emphasis in the Rails community on event-driven I/O.</p><p><em>Smashing Boxes is a web and mobile app development company know for creating a lasting experience through bold design and disrupting the status quo. We are entrepreneurs and craftsmen first, and a digital creative agency second. Inspired by our visionary clients, we transform ideas into innovative web and mobile applications. </em><a href=\"http://smashingboxes.com/work\">Take a look at our work.</a></p><p><em>Cover photo by&nbsp;</em><a href=\"https://www.flickr.com/photos/raneko/\" style=\"background-color: initial;\"><em>Raneko</em></a></p>",
  "Slug": "next-generation-web-framework",
  "slug_history": "--- []\n",
  "visits": 1563,
  "Published": "2012-06-22T04:00:00+00:00",
  "Authorname": "Reed Law",
  "category_id": 1,
  "image_uid": "2014/07/29/18/11/21/927/file",
  "created_at": "2014-06-05T18:25:17+00:00",
  "updated_at": "2014-08-11T15:00:55+00:00",
  "markdown": null,
  "image_alt_text": null,
  "featured": false,
  "database_id": 313,
  "category": {
    "type": "Entry",
    "id": "category_1"
  }
}