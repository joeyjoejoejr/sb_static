{
  "id": "post_347",
  "Title": "Test Driven Development (TDD) Part I -- Background",
  "Summary": "The \"test-first\" concept is in opposition to our natural instinct to start writing code as soon as we come up with an implementation in our head, however naïve it may be. But what some developers don't realize is that by writing code without tests, they are relying on a poor man's TDD.",
  "Body": "<h3 id=\"sec-1-1\">What is TDD?</h3><p>\r\n  At its core, Test Driven Development (TDD) is a very simple idea: write a test before writing a new feature. Although Kent Beck is often credited with the discovery of TDD, he himself \r\n\t<a href=\"http://www.quora.com/Test-Driven-Development/Why-does-Kent-Beck-refer-to-the-rediscovery-of-test-driven-development\">says he found it described in an ancient book about programming on tape</a>. The book described manually typing the expected output on one tape and then programming until the actual output matches the expected output. The principle may have been around earlier but Kent Beck is responsible for popularizing it through his 2002 book, <em>Test-Driven Development: By Example</em>.</p><p>\r\nThis \"test-first\" concept is in opposition to our natural instinct to start writing code as soon as we come up with an implementation in our head, however naïve it may be. But what some developers don't realize is that by writing code without tests, they are relying on a poor man's TDD. The developer writes a tentative method, then starts a debugger and manually triggers the method with ad hoc data. As soon as it seems to be working, he moves on to other code. Periodically the developer runs the entire application and performs a few sanity checks just to be sure everything works together. Finally, the code is deployed and the inevitable bug reports stream in. Bugs are patched quickly, often uncovering new bugs which are sometimes caught before they go live on production. Assuming the application doesn't require constant addition of new features, the app continues running and the frequency of bug reports gradually lessens until finally an equilibrium is reached in which all bugs are either fixed or are well-enough understood to be considered \"quirks\" or even \"features\".</p><p>\r\nTDD encourages developers to admit that each line of code needs testing. Rather than testing in an ad hoc way, a test framework should be used in order to explicitly define tests. And if we're going to write tests for our code, why not write the test first so that we have something with which to check our work? TDD is the logical conclusion of the premise that tests help us write better code.</p><p>\r\nWriting a test in the Test Driven Development style is similar to the old practice of typing expected output on tape. If we know our inputs we should have an expectation about what the exact output of our code will be. We can't test every possible value for each input, but we can at least test an expected range of values. Code should be written in such a way as to handle values that are outside of expected ranges. Tests can be either positive, affirming something works, or negative, ensuring that bad data raise exceptions.</p><p>\r\nLet's look at the simplest example. How can we use TDD to write an addition function?</p><h4 id=\"sec-1-1-1\">Set up</h4><p>\r\nFirst we write an empty test and an empty class in order to get things running.</p><p>\r\n\t<code>addition1_spec.rb</code></p><pre class=\"src src-ruby\">require 'rspec/core'\r\nrequire './addition1'\r\ndescribe Addition do\r\n  it \"adds two numbers\" do\r\n  end\r\nend\r\n</pre><p>\r\n\t<code>additional1.rb</code></p><pre class=\"src src-ruby\">class Addition\r\nend\r\n</pre><p>\r\nNow run the test:</p><pre class=\"src src-sh\">rspec ./addition1_spec.rb\r\n</pre><p>\r\nAnd we get:</p><pre class=\"example\">.\r\nFinished in 0.00024 seconds (files took 0.09515 seconds to load)\r\n1 example, 0 failures\r\n</pre><p>\r\nThis step is to make sure we don't have any problems with our testing environment. We can now proceed to the actual test writing.</p><h4 id=\"sec-1-1-2\">Test first</h4><p>\r\nNow we'll add a failing test. This is the \"Red\" part of the \"Red, Green, Refactor\" test cycle.</p><p>\r\n\t<code>addition2_spec.rb</code></p><pre class=\"src src-ruby\">require 'rspec/core'\r\nrequire './addition2'\r\ndescribe Addition do\r\n  it \"adds two numbers\" do\r\n    result = subject.add(2, 2)\r\n    expect(result).to eq(4)\r\n  end\r\nend\r\n</pre><p>\r\n\t<code style=\"display:inline;background:white;color:#444;\">subject</code> is a new instance of <code style=\"display:inline;background:white;color:#444;\">Addition</code>. When we call <code style=\"display:inline;background:white;color:#444;\">add</code> on <code style=\"display:inline;background:white;color:#444;\">subject</code> with the arguments <code style=\"display:inline;background:white;color:#444;\">2, 2</code> we expect the result to equal <code style=\"display:inline;background:white;color:#444;\">4</code>. <code style=\"display:inline;background:white;color:#444;\">eq</code> is Rspec's equivalent to the == operator.</p><p>\r\n\t<code>addition2.rb</code></p><pre class=\"src src-ruby\">class Addition\r\n  def add(x, y)\r\n end\r\nend\r\n</pre><p>\r\nWe write the empty \r\n\t<code style=\"display:inline;background:white;color:#444;\">add</code> method so that our test can run without throwing an exception. The test case will fail because <code style=\"display:inline;background:white;color:#444;\">result</code> doesn't equal <code style=\"display:inline;background:white;color:#444;\">4</code>, not because of a <code style=\"display:inline;background:white;color:#444;\">NoMethodError</code>.</p><p>\r\nAnd run the test:</p><pre class=\"src src-sh\">rspec ./addition2_spec.rb\r\n</pre><pre class=\"example\">F\r\nFailures:\r\n  1) Addition adds two numbers\r\n     Failure/Error: expect(result).to eq(4)\r\n       expected: 4\r\n            got: nil\r\n       (compared using ==)\r\n     # ./addition2_spec.rb:8:in `block (2 levels) in &lt;top (required)&gt;'\r\nFinished in 0.00074 seconds (files took 0.36751 seconds to load)\r\n1 example, 1 failure\r\nFailed examples:\r\nrspec ./addition2_spec.rb:6 # Addition adds two numbers\r\n</pre><p>\r\nAs expected, our test fails because we didn't actually implement the \r\n\t<code style=\"display:inline;background:white;color:#444;\">Addtion#add</code> method.</p><h4 id=\"sec-1-1-3\">Implement the method</h4><p>\r\nNow write just enough code to pass the test.</p><p>\r\n\t<code>addition3.rb</code></p><pre class=\"src src-ruby\">class Addition\r\n  def add(x, y)\r\n    x + y\r\n  end\r\nend\r\n</pre><p>\r\nAnd run the test:</p><pre class=\"src src-sh\">rspec ./addition3_spec.rb\r\n</pre><pre class=\"example\">.\r\nFinished in 0.00035 seconds (files took 0.06439 seconds to load)\r\n1 example, 0 failures\r\n</pre><p>\r\nOur test passes. Now we'd go on to refactoring if this were a more realistic example. For each change we make we re-run our test and ensure that everything is still working as expected.</p><p>\r\nThis is the simplest example of what TDD looks like. In a future blog post we'll look at more realistic examples.</p><h3 id=\"sec-1-2\">What's the controversy over?</h3><p>\r\n  So if TDD can help us write better code, why would some developers oppose it? </p><p>Recently a debate began over a keynote and \r\n\t<a href=\"http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html\">blog post</a> by David Heinemeier Hansson, original author of Ruby on Rails. His main concern with TDD centers around the possibility of design damage due to a dogmatic test-drivenness that insists on keeping tests fast at all costs, extensive mocking,  and 100% coverage at the unit level. Kent Beck and Martin Fowler, both proponents of TDD, <a href=\"http://martinfowler.com/articles/is-tdd-dead/\">held a series of conversations</a> with David in which they each described the benefits and shortcomings of TDD and attempted to clear up some misconceptions about the terminology and best practices associated with TDD. </p><p>As influential as each of them are, their opinions will continue to influence developers as they face the same trade-offs. The debate will continue at least until we come up with better practices, but many fundamental things will stay the same. All engineering involves trade-offs, so there will never be a silver bullet that solves all problems. We shouldn't neglect the collected wisdom of those who have gone before us. If we do neglect their experiences, we will inevitably repeat their mistakes and make their discoveries vain as we struggle to re-discover on our own. </p><p>In future blog posts, I will look more at the evidence that TDD works, look at some practical examples, and explore alternatives to TDD.<br></p><p><em>Check out TDD for beginners <a href=\"http://smashingboxes.com/ideas/beginners-guide-to-test-driven-development-tdd\">here</a>.</em></p>",
  "Slug": "tdd-part-1-background",
  "slug_history": "--- []\n",
  "visits": 3140,
  "Published": "2014-09-12T04:33:40+00:00",
  "Authorname": "Reed Law",
  "category_id": 1,
  "image_uid": "2014/09/11/12/32/31/509/file",
  "created_at": "2014-09-10T09:57:52+00:00",
  "updated_at": "2015-06-15T19:16:37+00:00",
  "markdown": "",
  "image_alt_text": "",
  "featured": false,
  "database_id": 347,
  "category": {
    "type": "Entry",
    "id": "category_1"
  }
}