{
  "id": "post_365",
  "Title": "Caching Dragonfly Images",
  "Summary": "",
  "Body": "<h1>Dragonfly</h1>\r\n<pre>class User &lt; ActiveRecord::Base\r\n  dragonfly_accessor :avatar do\r\n    default 'public/images/default_avatar.png'\r\n  end\r\n  validates_property :ext, of: :avatar, in: %w(jpg jpeg gif png)\r\nend\r\n\r\nclass UserDecorator\r\n  def avatar_url(size = nil)\r\n    return unless self.avatar\r\n    s = case size\r\n    when :small\r\n     \"200x200#\"\r\n    else #default\r\n     \"800x800\"\r\n    end\r\n    self.avatar.thumb(s).url\r\n  end\r\nend\r\n</pre><p>\r\n\t<strong><br>\r\n\t</strong></p><p>Dragonfly is a gem (1600+ stars)&nbsp;that helps with file uploads. One of the main differentiator between it and others (ex:&nbsp;carrierwave) instead of making thumbnails at upload,&nbsp;images are resized when they are first&nbsp;rendered. Then they are <strong>cached</strong>. In other words, it allows for on the fly image processing.&nbsp;&nbsp;Here are some gotchas to lookout for.</p><h2>\r\n\t<strong>Gotcha #1:&nbsp;Caching / Performance</strong></h2><p>\r\n\t\t\tDragonfly generates images on the fly. In order to keep processing low, it needs to store the resulting images in some sort of cache. From the dragonfly docs we read:</p><blockquote>\r\n\t<p>\r\n\t\t\t\tSimply put a proxy like \r\n\t\t<a href=\"http://rtomayko.github.com/rack-cache\">Rack::Cache</a>, <a href=\"http://varnish.projects.linpro.no/\">Varnish</a> or <a href=\"http://www.squid-cache.org/\">Squid</a> in front of the app and subsequent requests will be served super-quickly straight out of the cache.<br>\r\n\t\t\t\tFor simple use of Rack::Cache with rails see \r\n\t\t<a href=\"http://markevans.github.io/dragonfly/rails#caching\">Rails</a>.\r\n\t</p></blockquote><p>\r\n\t\t\tUsing Rack::Cache with memcached is not recommended in production, especially if there are lots of images or these images are large in size. If you do use Rack::Cache, make sure to change the memcached file size limit (1MB by default).</p><p>\r\n\t\t\t<strong>Rack::Cache</strong> ships with three different storage engines: \r\n\t<code>file</code>, <code>heap</code>, and <code>memcache</code>. Storing data in the <code>file</code> engine is slower but memory efficient. Using <code>heap</code> means your process’ memory will be used which is quicker but can have an impact on performance if it grows unbounded. Using <code>memcache</code> is the fastest option though it isn’t well suited to store large objects.&nbsp;Heroku recommends using the MetaStore with the memcache storage engine, which allows very quick access to shared meta-data, while using the file engine for the EntityStore and its larger objects results in an efficient and predictable application performance profile.</p>\r\n<pre>config.action_dispatch.rack_cache = {\r\n    :metastore    =&gt; 'memcached://localhost:11211/meta',\r\n    :entitystore =&gt;  URI.encode(\"file:#{Rails.root}/tmp/dragonfly/cache/body\")\r\n}\r\nconfig.static_cache_control = \"public, max-age=2592000\"\r\n</pre><p>&nbsp;See&nbsp;\r\n\t<a href=\"http://rtomayko.github.com/rack-cache/storage\">Rack Cache Storage</a> for all the rack::cache configuration options.</p><p>The alternative is to use a <strong>CDN</strong>:</p><blockquote>\r\n\tHeroku recommends using a \r\n\t<a href=\"https://devcenter.heroku.com/articles/using-amazon-cloudfront-cdn\">CDN to speed up delivery of assets</a> for the fastest visitor experience. If you are already using a CDN, then adding <code>Rack::Cache</code> will not speed up delivery of assets. If you do not wish to use a CDN,<code>Rack::Cache</code> is an good way to speed up asset delivery.<br>\r\n</blockquote><p>Finally, another alternative is to let <strong>NGINX</strong> to do the caching. To do so we need to edit the config file (/tmp/nginx_conf) to look something like:</p>\r\n<pre>proxy_cache_path /opt/nginx/cache/dragonfly levels=2:2 keys_zone=dragonfly:100m inactive=30d max_size=1g;\r\n\r\nserver{\r\n  ....\r\n  location ^~ /media/ {\r\n    proxy_pass http://unicorn;\r\n    proxy_cache dragonfly;\r\n    proxy_cache_valid      200  30d;\r\n  }\r\n}\r\n</pre><p>This example will cache all request to /media/*, which is the path used by Dragonfly by default. More info on NGINX can be found here:&nbsp;<a href=\"http://nginx.com/resources/admin-guide/caching/.\">http://nginx.com/resources/admin-guide/caching/.</a></p><h2>\r\n\t<strong>Gotcha #2:&nbsp;Testing</strong></h2><p><strong></strong><br>\r\n\t\t\tThe Memory data store keeps everything in memory and is useful for things like tests.\r\n\t<br>\r\n\t\t\tTo use:\r\n\t<br>\r\n\t<code>Dragonfly.app.configure do datastore :memory # ... end</code></p>",
  "Slug": "dragonfly-vs-carrierwave",
  "slug_history": "--- []\n",
  "visits": 0,
  "Published": null,
  "Authorname": "",
  "category_id": 1,
  "image_uid": null,
  "created_at": "2014-12-15T18:39:30+00:00",
  "updated_at": "2015-04-03T20:11:47+00:00",
  "markdown": "",
  "image_alt_text": "",
  "featured": false,
  "database_id": 365,
  "category": {
    "type": "Entry",
    "id": "category_1"
  },
  "tags": [
    {
      "type": "tag",
      "id": "tag_2"
    }
  ]
}