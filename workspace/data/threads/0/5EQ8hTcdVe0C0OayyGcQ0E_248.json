{
  "id": "post_248",
  "title": "Domain Logic in Rails",
  "summary": "What is Domain Logic? All software has a domain in which it attempts to solve problems. This can be equivalent to a real-world business or to a field of engineering or math. The domain logic is the representation of the business rules of the domain being modeled. In object-oriented software engineering, a domain object model…",
  "body": "<h3>What is Domain Logic?</h3><p>\r\n\tAll software has a domain in which it attempts to solve problems. This can be equivalent to a real-world business or to a field of engineering or math. The domain logic is the representation of the business rules of the domain being modeled. In object-oriented software engineering, a domain object model is used to model problem domain objects, or objects that have a direct counterpart in the problem domain. \r\n\t<a title=\"Ivar Jacobson, Object-Oriented Software Engineering: A Use Case Driven Approach\" href=\"https://en.wikipedia.org/wiki/Special:BookSources/0201544350\" target=\"_blank\">[1]</a>\r\n</p><p>\r\n\tTraditionally, domain logic in \r\n\t<a href=\"http://rubyonrails.org/\" target=\"_blank\">Ruby on Rails</a> is modelled in <a title=\"ActiveRecord::Base\" href=\"http://api.rubyonrails.org/classes/ActiveRecord/Base.html\" target=\"_blank\">ActiveRecord</a> models. ActiveRecord is the default object-relational mapping (ORM) library for Rails. Hence, objects that represent domain logic are also responsible for persisting or saving data attributes to a relational database.\r\n</p><h3>The Great Debate</h3><p>\r\n\tThere are two radically different schools of thought on combining domain logic with a persistence layer or ORM. First, we have Uncle Bob, one of the authors of the \r\n\t<a title=\"Authors: The Agile Manifesto\" href=\"http://www.agilemanifesto.org/authors.html\" target=\"_blank\">Agile Manifesto</a>:\r\n</p><blockquote>\r\n\t\r\n\t\t“The opportunity we miss when we structure our applications around Active Record is the opportunity to use object oriented design.” \r\n\t\t<a title=\"Robert Martin, Active Record Vs. Objects\" href=\"https://sites.google.com/site/unclebobconsultingllc/active-record-vs-objects\" target=\"_blank\">[2]</a>\r\n\t</blockquote><p>\r\n\tThe context of that quote is about the confusion caused when you have objects that also happen to be data structures. Objects in object-oriented programming are diametrically opposed to data structures. Objects expose behavior while data structures have no behavior.\r\n</p><p>\r\n\tThen, we have David Heinemeier Hansson–creator of Rails, proponent of opinionated software:\r\n</p><blockquote class=\"twitter-tweet\" lang=\"en\">\r\n\t\r\n\t\t<a href=\"https://twitter.com/dhh\">@dhh</a> — It’s great to hear your comments on the latest memes in Rubyland/web dev. What are your thoughts on separating logic + persistence.\r\n\t<br>\r\n\t\r\n\t\t— Paul Campbell (@paulca) \r\n\t\t<a href=\"https://twitter.com/paulca/statuses/218740007878406145\">June 29, 2012</a>\r\n\t</blockquote><p>\r\n\tFrom this tweet we can see DHH’s opinion that a Rails application is a web app and nothing else. We shouldn’t be concerned about separating non-application specific business logic from our framework. We shouldn’t need to re-use our domain logic outside of Rails.\r\n</p><p>\r\n\tSo we have a dilemma. Should we follow Uncle Bob’s advice and isolate our domain logic from our database layer? Or should we keep on doing things the Rails way and use the active record pattern (which also happens to be named \r\n\t<a href=\"http://api.rubyonrails.org/classes/ActiveRecord/Base.html\">ActiveRecord</a>) to both model behavior and persist data?<br>\r\n\t<img class=\"aligncenter size-full wp-image-4141\" alt=\"bob-vs-dhh\" src=\"http://sbblog.s3.amazonaws.com/wp-content/uploads/2013/10/bob-vs-dhh.jpg\" height=\"300\" width=\"600\">\r\n</p><h3>The Problem with Rails</h3><p>\r\n\tIn many cases, DHH is right. Our little pet-project blog app is nothing more than a blog. Its business logic is intimately tied to the delivery platform—the web. There is no need to separate out the domain logic. It’s just a simple CRUD app.\r\n</p><p>\r\n\tBut what happens when your app is more than just a blog? What if your application needs to model complex behavior—say, a payroll app. You have dozens of models and your tests start to take longer and longer with complex database interactions. Then you start wanting to separate out business logic by \r\n\t<a href=\"https://www.destroyallsoftware.com/screencasts/catalog/extracting-domain-objects\">extracting domain objects</a>. You mock or stub out your tests and they are moving fast again. But still, your views and controllers are tightly coupled with your models, reaching far inside to extract data. It can’t all be tested easily except by huge integration tests.\r\n</p><p>\r\n\tIf those problems sound all too familiar, you might be ready to re-discover some practices and approaches that have worked well in the history of software engineering.\r\n</p><h3>The Solution: Object-Oriented Design</h3><p>\r\n\tIt just so happens that what’s needed to speed up our tests is the same things that are good for object-oriented software design. There are a handful of time-tested approaches that can make our applications faster, easier to maintain, and more bug-free. The first principle is single-responsibility. Each class should be responsible for a single concern. Put another way, classes should only have a single reason to change. If a class is responsible for too much it will require frequent changes and make the application more fragile.\r\n</p><p>\r\n\tRails’ models, which inherit from ActiveRecord::Base, are responsible for both domain logic and persistence. This is one responsibility too many. So the first step in refactoring a fragile Rails application is putting all domain logic in Plain Old Ruby Objects (POROs). Free from the constraints of the database we can now model our domain in a fully object-oriented way. We can use object-oriented design patterns such as inheritance, facades, decorators, and so on. For a full description of many such design patterns a good reference is \r\n\t<a href=\"https://en.wikipedia.org/wiki/Design_Patterns\"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></a>.\r\n</p><h5><strong>Dependency Inversion</strong></h5><p>\r\n\tThe next approach we will explore is creating a boundary that inverts the dependencies between controllers, views, and models. According to Uncle Bob’s \r\n\t<a href=\"http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\" target=\"_blank\">Clean Architecture</a>, software dependencies should all point towards higher-level business rules. The database, web, and other external interfaces thus become the lowest-level implementation details. This is the reverse of how Rails applications are often designed. Usually, the database design is considered first and then ActiveRecord models are created with a near one-to-one mapping to database tables. Clean architecture turns that process upside down and has you consider your domain logic far ahead of the database.\r\n</p><p>\r\n\tOnce you have a test-driven domain object model that begins to fully model and implement your business rules, you can begin to focus on the interfaces that control the boundaries between the web and the actual domain logic.\r\n</p><h5><strong>Use Cases</strong></h5><p>\r\n\tThe interfaces that interact with the database, web, external services on the one side, and your domain entities on the other side, are called Use Cases. A use case can also be described as a User Story. A use case defines the interaction between a role and part of the system. There are special syntaxes for describing use cases, such as \r\n\t<a href=\"http://cukes.info/\" target=\"_blank\">Cucumber</a> steps. But in simple form a use case can be described in terms such as “a user logging in”, or “a manager adding a new employee”.\r\n</p><p>\r\n\tIn Rails, use cases can be implemented through Interactor models that take request objects passed in through the controller and return response objects that get rendered in the view. The request and response objects are simple data structures with no behavior or logic. Interactors can thus interact with controllers, domain objects, and repositories.\r\n</p><h5><strong>Repositories</strong></h5><p>\r\n\tAt this point you may be thinking we’re throwing all of Rails out. But we’re not. In fact, we are going to keep on using ActiveRecord::Base as the base class for our repository models. The name repository implies a data store. So these repository models are responsible only for storing and retrieving data. We can use the full \r\n\t<a href=\"http://guides.rubyonrails.org/active_record_querying.html\" target=\"_blank\">Active Record query interface</a> if we want to, or drop down into plain SQL. It doesn’t matter how we implement repositories as long as our dependencies point away from them. With inverted depencies our application is loosely coupled and we can freely refactor domain logic without caring about the implementation details of the persistence layer.\r\n</p><p>\r\n\t<img class=\"aligncenter size-full wp-image-4292\" alt=\"clean_rails_diagram\" src=\"http://sbblog.s3.amazonaws.com/wp-content/uploads/2013/10/clean_rails_diagram.png\" height=\"628\" width=\"600\">\r\n</p><h3>An Example in Rails</h3><p>\r\n\tWe tried this approach in a Rails app that had already been under development for a few months. The complexity of the domain led us to the decision to refactor away from the traditional Rails way towards this type of clean architecture. Immediately the benefits could be felt when running tests. The old tests were already taking about 30 seconds without too many cases. The new tests run in about a second and we can now freely add new ones without fear of slowing them down. Our domain logic was completely refactored from a database-centric one to a properly object-oriented one. This simplified the many table joins we had to do previously. Now we use object inheritance to group similar concepts and can get the behavior we need without complex database queries.\r\n</p><h5><strong>How it’s Done</strong></h5><p>\r\n\tFirst, I started off in a new clean directory and added a lib/ and spec/. Using test-first development, I started creating entities. Entities are where all the domain logic lives. They inherit from a base class called Entity.\r\n</p><pre>class Entity\r\n  include ActiveModel::Validations\r\n  attr_accessor :id\r\n  def self.attr_accessor(*vars)\r\n    @class_attributes ||= [:id]\r\n    @class_attributes.concat vars\r\n    super(*vars)\r\n  end\r\n  def self.class_attributes\r\n    @class_attributes\r\n  end\r\n  def self.inherited(sublass)\r\n    sublass.attr_accessor(*@class_attributes)\r\n  end\r\n  def initialize(attr = {})\r\n    attr.each do |name, value|\r\n      send(\"#{name}=\", value)\r\n    end\r\n  end\r\nend\r\n</pre><p>\r\n\t<br>\r\n I’m interested in the class and object attributes because it’s convenient for validations.\r\n</p><p>\r\n\tNext, I implemented the Interactor base class.\r\n</p><pre>class Interactor\r\n  attr_reader :request, :response\r\n\r\n  def initialize(request = {})\r\n    @request = request\r\n    @response = Response.new\r\n  end\r\n\r\n  private\r\n\r\n  def save_repository(repo_class)\r\n    if @request.params[:id]\r\n      repo = repo_class.find(@request.params[:id])\r\n      repo.update_attributes(@request.object_attributes)\r\n    else\r\n      repo = repo_class.create(@request.object_attributes)\r\n    end\r\n    repo\r\n  end\r\n\r\n  def delete(repo_class)\r\n    repo = repo_class.find(@request.params[:id])\r\n    repo.destroy\r\n  end\r\nend\r\n\r\n</pre><p>\r\n\t<br>\r\nNotice there is a convenience method there used to save data into a repository. It can handle either create or update, depending on the params passed by the controller.\r\n</p><p>\r\n\tWhat do the request and response objects look like?\r\n</p><p>\r\n\tThese have some behavior that make it easy to integrate Rails form helpers. For example, a response object that contains an id will be considered as a persisted record by a Rails form and so the form action will be the update url rather than the create url. They both are \r\n\t<a href=\"https://github.com/intridea/hashie\">Hashie::Mash</a> objects because that makes accessing attributes cleaner.\r\n</p><p>\r\n\tNow how does this integrate with Rails? It’s simple. After I finished the basic domain object model and a couple of interactors, I dropped them into the Rails app directory. Be sure to add paths to entities and interactors in your autoload paths in config/application.rb. The application controller loads commonly used data attributes into every request:\r\n</p><pre>class ApplicationController &lt; ActionController::Base\r\n  before_filter :set_default_request\r\n\r\n  def current_account_id\r\n    @current_account_id ||= current_user.account_repository_id if user_signed_in?\r\n  end\r\n  helper_method :current_account_id\r\n\r\n  protected\r\n\r\n  def set_default_request\r\n    if current_user\r\n      @request = Request.new(current_user: current_user,\r\n                             current_account_id: current_account_id,\r\n                             params: params)\r\n    else\r\n      @request = Request.new(params: params)\r\n    end\r\n  end\r\nend\r\n\r\n</pre><p>\r\n\tYou’ll see there are still some ActiveRecord associations being used, partly in order to make \r\n\t<a href=\"https://github.com/plataformatec/devise\">Devise</a> work. A user belongs to an account and both have their data stored in repositories. So what does a repository look like? Very simple, no logic:\r\n</p><pre># == Schema Information\r\n#\r\n# Table name: user_repository\r\n#\r\n#  id                       :integer          not null, primary key\r\n#  account_repository_id    :integer\r\n#  first_name               :text\r\n#  last_name                :text\r\n#  state                    :text\r\n#  email                    :string(255)      default(\"\"), not null\r\n#  encrypted_password       :string(255)      default(\"\"), not null\r\n#  reset_password_token     :string(255)\r\n#  reset_password_sent_at   :datetime\r\n#  remember_created_at      :datetime\r\n#  sign_in_count            :integer          default(0), not null\r\n#  current_sign_in_at       :datetime\r\n#  last_sign_in_at          :datetime\r\n#  current_sign_in_ip       :string(255)\r\n#  last_sign_in_ip          :string(255)\r\n#\r\n\r\nclass UserRepository &lt; ActiveRecord::Base\r\n  self.table_name = 'user_repository'\r\n  belongs_to :account, class_name: 'AccountRepository', foreign_key: :account_repository_id\r\n  devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable\r\nend\r\n</pre><p>\r\n\tNow controllers simply route traffic and call interactors to perform the actual use cases:\r\n</p><pre>class UsersController &lt; ApplicationController\r\n  respond_to :html\r\n  before_filter :authenticate_user!\r\n\r\n  def user_params\r\n    params.require(:user).permit :first_name, :last_name, :email, :password, :password_confirmation, :phone\r\n  end\r\n  private :user_params\r\n\r\n  def index\r\n    @response = BrowseUsers.new(@request).call.extend(UserPresenter)\r\n    respond_with @response\r\n  end\r\n\r\n  def show\r\n    @response = LoadUser.new(@request).call\r\n    respond_with @response\r\n  end\r\n  alias_method :edit, :show\r\n\r\n  def new\r\n    @response = NewUser.new(@request).call\r\n    respond_with @response\r\n  end\r\n\r\n  def create\r\n    @request.object_attributes = user_params\r\n    @response = SaveUser.new(@request).call\r\n    respond_with @response.user, location: users_path\r\n  end\r\n  alias_method :update, :create\r\n\r\n  def destroy\r\n    @response = DeleteUser.new(@request).call\r\n    respond_with @response, location: users_path\r\n  end\r\nend\r\n</pre><p>\r\n\t<br>\r\n We make use of presenters to handle presentation details as well. The call method on an interactor instance always takes a @request object and returns a @response object which can be a nested data object. The views only know about what’s in @response. It is the interactor’s duty to get the data required for the view from the repository. Views know nothing about ActiveRecord, entities, or the database. Repositories know nothing about business rules or domain logic.\r\n</p><p>\r\n\tFinally, here’s a set of interactors that can handle simple CRUD operations:\r\n</p><pre>class LoadLocation &lt; Interactor\r\n  def call\r\n    @response.location = location.attributes\r\n    @response\r\n  end\r\n\r\n  def location\r\n    LocationRepository.joins(:manager)\r\n      .select(\"*, user_repository.name AS manager_name\")\r\n      .where(account_repository_id: @request.current_account_id)\r\n      .find(@request.params[:id])\r\n  end\r\nend\r\n\r\nclass LoadLocations &lt; Interactor\r\n  def call\r\n    @response.locations = locations\r\n    @response\r\n  end\r\n\r\n  def locations\r\n    LocationRepository.joins(:manager)\r\n      .select(\"*, user_repository.name AS manager_name\")\r\n      .where(account_repository_id: @request.current_account_id)\r\n      .map(&amp;:attributes)\r\n  end\r\nend\r\n\r\nclass SaveLocation &lt; Interactor\r\n  def call\r\n    location = Location.new(@request.object_attributes)\r\n    if location.valid?\r\n      repo = save_repository(LocationRepository)\r\n      @response.location = repo.attributes\r\n    else\r\n      @response.location = @request.object_attributes\r\n      @response.location.errors = location.errors\r\n    end\r\n    @response\r\n  end\r\nend\r\n\r\nclass DeleteLocation &lt; Interactor\r\n  def call\r\n    @response = delete(LocationRepository)\r\n  end\r\nend\r\n</pre><h3>Conclusion</h3><p>\r\n\tThis is a very different way of doing things as far as Rails goes. It offers a clean boundary between application logic and implementation details. It would be quite easy to refactor an app like this into a Sinatra app. Or it could even use a different language for the delivery mechanism. External services should be easy to plugin. Likewise for database backends and ORMs. But most importantly, implementing a Rails app using a clean architecture reminds us to keep up the red-green-refactor TDD cycle and to make sure our models only have a single responsibility. Yes, it is more work this way but this is a case of not being penny wise and pound foolish. We can build seemingly powerful applications very quickly in Rails. But if we want to keep maintaining and refactoring and adding features for years, that initial productivity boost that Rails affords us will quickly run out and leave us with a big ball of mud.\r\n</p><p>\r\n\tComment below with your thoughts. \r\n</p><p>\r\n\t<em>Cover image by </em><a href=\"https://www.flickr.com/photos/cogdog/\" style=\"background-color: initial;\"><em>Alan Levine</em></a>\r\n</p>",
  "slug": "domain-logic-in-rails",
  "slug_history": "--- []\n",
  "visits": 15057,
  "published": "2014-12-04T12:09:33+00:00",
  "authorName": "Reed Law",
  "category_id": 1,
  "image_uid": "2014/07/28/17/25/40/693/file",
  "created_at": "2014-06-05T18:21:54+00:00",
  "updated_at": "2015-06-15T19:12:18+00:00",
  "markdown": "",
  "image_alt_text": "",
  "featured": false,
  "database_id": 248,
  "category": {
    "type": "Entry",
    "id": "category_1"
  },
  "tags": [
    {
      "type": "tag",
      "id": "tag_2"
    },
    {
      "type": "tag",
      "id": "tag_2"
    }
  ],
  "authors": [
    {
      "type": "employee",
      "id": "employee_18"
    },
    {
      "type": "employee",
      "id": "employee_18"
    }
  ]
}