{
  "id": "post_384",
  "title": "Merging Rails and Ember-CLI - Part III",
  "summary": "In the final part of the Merging Ember-cli with Rails blog series, we discuss how we connected the Ember frontend with the Rails backend so that beer rankings could be persisted in the database.",
  "body": "",
  "slug": "merging-rails-and-ember-cli-part-iii",
  "slug_history": "--- []\n",
  "visits": 3074,
  "published": "2015-07-08T12:00:00+00:00",
  "authorName": "",
  "category_id": 1,
  "image_uid": "2015/07/07/17/33/34/354/file",
  "created_at": "2015-07-07T20:08:55+00:00",
  "updated_at": "2015-07-22T14:20:40+00:00",
  "markdown": "In this third and **final** part of my \"Merging ember-cli with Rails\" blog series, I will talk about how I connected the Ember frontend with the Rails backend so that beer rankings could be persisted in the database.\r\n\r\n###Writing the AJAX call.\r\n\r\nIn [Part 2](http://smashingboxes.com/ideas/merging-rails-and-ember-cli-part-2) you may recall the `swap` controller action I put in my ballot controller. Well, that wasn't sending anything back to the Rails API. Every time I reloaded the browser, my beers were back in their original order. Let’s fix that.\r\n\r\n**EmberApp/app/controllers/ballot.js**\r\n\r\n```js\r\nimport Ember from 'ember';\r\n\r\nexport default Ember.Controller.extend({\r\n  sortProperties: ['weight'],\r\n\r\n  actions: {\r\n    swap: function(line_item_id_1, line_item_id_2) {\r\n      var li1, li1_weight, li2, li2_weight;\r\n      li1 = this.model.get('line_items').findBy('id', line_item_id_1);\r\n      li2 = this.model.get('line_items').findBy('id', line_item_id_2);\r\n      li1_weight = li1.get('weight');\r\n      li2_weight = li2.get('weight');\r\n      li1.set('weight', li2_weight);\r\n      li2.set('weight', li1_weight);\r\n      return Ember.$.ajax({\r\n        url: \"/api/v1/ballots/\" + (this.model.get('id')) + \"/swap/\" + (li1.get('id')) + \"/\" + (li2.get('id')),\r\n        type: 'put'\r\n      }).done(function() {}).fail(function() {\r\n        li1.rollback();\r\n        return li2.rollback();\r\n      });\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nNote the addition of the AJAX call at the end of the `swap` action in the ballot controller. There is likely a cleaner and more Ember(y) way to do this, and I would love to hear it in the comments below; however, that call got the job done for me and it's good enough to finish out this drag and drop prototype. I opened my console and was pleased to see an AJAX PUT network request after a drop event. Let’s set up our Rails API endpoint.\r\n\r\n###The Coupling\r\n\r\nIn my head, I know I want the interaction between my Ember and Rails apps to look like this:\r\n\r\n```\r\n ----------------                                      -------------------\r\n|                |   PUT: /api/v1/ballots/1/swap/1/2  |                   |\r\n| Ember Frontend |   ==============================>  | Rails API Backend |\r\n|                |                                    |                   |\r\n ----------------                                      -------------------\r\n```\r\n\r\nThat is *really* all we need. A single endpoint that says \"swap the weight of line item 1 and line item 2 on ballot 1.\" That way, we keep the data on our backend API in sync with that is going on in the Ember frontend.\r\n\r\nSo, let’s do a little Rails to get this all set up. We are going to generate a ballot controller, then update the routes to access the request to `/api/v1/ballots/:id/swap/:li1_id/:li2_id`\r\n\r\n```sh\r\n$ rails g controller Api::V1::Ballots\r\n```\r\n\r\n**config/routes.rb**\r\n\r\n```ruby\r\nnamespace :api do\r\n  namespace :v1 do\r\n    resources :ballots do\r\n      put '/swap/:li1/:li2', to: 'ballots#swap'\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThen make yourself a controller action for swap.\r\n\r\n**app/controllers/ballots_controller.rb**\r\n\r\n```ruby\r\nclass Api::V1::BallotsController < ApplicationController\r\n  respond_to :json\r\n\r\n  def swap\r\n    ballot = Ballot.find(params[:ballot_id])\r\n    ballot.swap(LineItem.find(params[:li1]), LineItem.find(params[:li2]))\r\n    if ballot.save\r\n      render json: {}\r\n    else\r\n      render status: 500\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nLastly, I added this method to my `Ballot` model to handle swapping line items.\r\n\r\n**app/models/ballots.rb**\r\n\r\n```ruby\r\ndef swap(li1, li2)\r\n  li1_weight = li1.weight\r\n  li2_weight = li2.weight\r\n  li1.weight = li2_weight\r\n  li2.weight = li1_weight\r\n  li1.save && li2.save\r\nend\r\n```\r\n\r\nSo that should work well. Right?\r\n\r\n###Dealing with Rails CSRF\r\n\r\nThat AJAX PUT **should** have worked but our Rails API is throwing back a crazy error.\r\n\r\n```ruby\r\nActionController::InvalidAuthenticityToken\r\n```\r\n\r\nWhat is going on now is that Rails is kicking back our request due to a missing CSRF token. Luckily, there is a CSRF ember npm package we can install that will handle setting the token in all our request headers.\r\n\r\n```sh\r\n$ npm install --save rails-csrf\r\n```\r\n\r\nOnce that is done running, update your `app.js` to include your new module and your `routes/index.js` to request the rails CSRF token before page load:\r\n\r\n**EmberApp/app/app.js**\r\n\r\n```js\r\nimport Ember from 'ember';\r\nimport Resolver from 'ember/resolver';\r\nimport loadInitializers from 'ember/load-initializers';\r\nimport config from './config/environment';\r\n\r\nEmber.MODEL_FACTORY_INJECTIONS = true;\r\n\r\nvar App = Ember.Application.extend({\r\n  modulePrefix: config.modulePrefix,\r\n  podModulePrefix: config.podModulePrefix,\r\n  Resolver: Resolver\r\n});\r\n\r\nloadInitializers(App, config.modulePrefix);\r\n\r\n//Initialize Rails CSRF\r\nloadInitializers(App, 'rails-csrf');\r\nimport { setCsrfUrl } from 'rails-csrf/config';\r\nsetCsrfUrl('api/v1/csrf');\r\n\r\n\r\nexport default App;\r\n```\r\n\r\n**EmberApp/app/routes/index.js**\r\n\r\n```js\r\nimport Ember from 'ember';\r\n\r\nexport default Ember.Route.extend({\r\n  controllerName: 'ballot',\r\n\r\n  beforeModel: function() {\r\n    return this.csrf.fetchToken();\r\n  },\r\n\r\n  model: function() {\r\n    return this.store.find('ballot', 1);\r\n  },\r\n  setupController: function(controller, model){\r\n    controller.set('model', model);\r\n  }\r\n});\r\n```\r\n\r\nNote the addition of \"beforeModel.\" This will request the csrf token from the backend before every page load, but we are not done yet. We need to support this request to `/api/v1/csrf` in our Rails application.\r\n\r\nFirst, we add this line to our routes.rb file underneath the `:api` and `:v1` namespace declarations.\r\n\r\n**routes.rb**\r\n\r\n```ruby\r\nget :csrf, to: 'csrf#index'\r\n```\r\n\r\nThen we will generate a simple CSRF controller to handle this request.\r\n\r\n```sh\r\n$ rails g controller Api::V1::Csrf index\r\n```\r\n\r\n**csrf_controller.rb**\r\n\r\n```ruby\r\nclass Api::V1::CsrfController < ApplicationController\r\n  def index\r\n    render json: { request_forgery_protection_token => form_authenticity_token }.to_json\r\n  end\r\nend\r\n```\r\n\r\nOnce that is complete. Restart your `rails server` then reload your Ember app. Now start dragging and dropping to modify your beer rankings. You should see that, on every drop event, an AJAX request is being sent back to the Rails application and updating the line items weights. Now, when you refresh your browser, your updates to beer rankings will be persisted!\r\n\r\n##Conclusion\r\n\r\nWhile it does take a *little* work to wire up a Rails/Ember application, they play quite well together! [Ember-Data's](https://github.com/emberjs/data) near perfect compatibility with [ActiveModelSerializers](https://github.com/rails-api/active_model_serializers) makes keeping your models up to date crazy simple. And, with the [Rails API becoming a first class citizen with Rails 5](https://github.com/rails/rails/pull/19832), I can see this flow becoming even **easier** in the coming future. So, if you are not a big fan of integrated frameworks like [meteor](https://www.meteor.com/#!) or [volt](http://www.voltframework.com/) than using Rails and Ember is a very elegant way to get a lot of work done fast!\r\n\r\n##Resources\r\n\r\n* [Part 1](http://smashingboxes.com/ideas/merging-rails-and-ember-cli)\r\n* [Part 2](http://smashingboxes.com/ideas/merging-rails-and-ember-cli-part-2)\r\n",
  "image_alt_text": "merging rails backend with ember-cli front end",
  "featured": true,
  "database_id": 384,
  "category": {
    "type": "Entry",
    "id": "category_1"
  },
  "tags": [
    {
      "type": "tag",
      "id": "tag_2"
    },
    {
      "type": "tag",
      "id": "tag_16"
    },
    {
      "type": "tag",
      "id": "tag_2"
    },
    {
      "type": "tag",
      "id": "tag_16"
    }
  ],
  "authors": [
    {
      "type": "employee",
      "id": "employee_69"
    },
    {
      "type": "employee",
      "id": "employee_69"
    }
  ]
}