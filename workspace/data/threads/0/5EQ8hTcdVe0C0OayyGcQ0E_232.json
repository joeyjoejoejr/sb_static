{
  "id": "post_232",
  "title": "The Power of Run Loops Compels You! ",
  "summary": "In my never-ending quest to try to understand everything about everything, I eventually had to figure out how scheduling mechanisms (Threads) work within Cocoa (the framework for Mac OSX & iOS Development). It isn’t as simple as you’d think. For example, a thread can be spawned and given an associated task which will be completed from start-to-finish. However,…",
  "body": "<p>In my never-ending quest to try to understand everything about everything, I eventually had to figure out how scheduling mechanisms (Threads) work within <a href=\"https://developer.apple.com/technologies/mac/cocoa.html\">Cocoa</a> (the framework for Mac OSX &amp; iOS Development). It isn’t as simple as you’d think. For example, a thread can be spawned and given an associated task which will be completed from start-to-finish. However, what about portions of your task that need to wait for a response before it can proceed further? What do you do with those?  In circumstances like these, Apple has included an event-processing mechanism called a “<a href=\"https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html\">Run Loop</a>”, which simplifies the amount of work a programmer needs to do to account for event-driven code.</p><p>I previously wrote a post about building an <a href=\"http://www.smashingboxes.com/dissecting-third-party-libraries-through-design-patterns/\">asynchronous networking library</a>. This article will dive even further into an important part of what makes it work, “Run Loops”, which are integral to performing asynchronous tasks.</p><p>So, first, what is a run loop? Apple’s documentation says:</p><p>“Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.” -Threading Programming Guide: “Run Loops”, Apple Inc.</p><p>So, let’s explore this a little further: A “thread” (for those of you reading this who don’t know) is a scheduling mechanism for queueing tasks to be processed by the CPU. These threads are managed by the operating system’s “scheduler”, and given a place in line where they are eventually executed. In the context of a multiprocessor environment, you can execute threads “concurrently” (at the same time). This allows software to perform certain time-consuming tasks in the background without slowing down the responsiveness of the user interface (what we call performing a task “asynchronously”).</p><p>There can be some hurdles while performing tasks asynchronously (namely, the synchronization, “re-coupling”, of data), but this is a topic that can be discussed at-length in another article. For now, let’s jump back to how run loops fit in.</p><p>In Cocoa and Cocoa-Touch development, run loops are the mechanism you will utilize to make sure your event-driven, asynchronous task properly responds to any activity that occurs during the lifespan of the thread it is operating within. If the events for the task are not allowed to occur, and aren’t responded to, you risk not acquiring, or utilizing, the data you need to complete the intent of the task. Below is a sample class diagram for the structure of a threaded, asynchronous task:</p><ul><li>Thread (this can be spawned using NSThread, Grand-Central Dispatch, NSOperation, or “performSelectorInBackground:”)</li><li>NSRunLoop/Task</li><li>Event-Driven Object (this is a class whose functionality requires time to process in order for events associated with it to occur. An example would be a running NSURLConnection object, or a socket)</li></ul><p>As you can see from above, the order of encapsulation begins with a thread, continues up the stack with the NSRunLoop and Task associated with it, and then finally into the context of the object which is utilizing the RunLoop. This dependency makes sure that the task has both its own space to operate, and the means to make sure its instructions are fully carried out.</p><p>To schedule your event-driven object/class within a run loop be sure to call the method below:</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [&lt;object/class&gt; scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode: NSRunLoopCommonModes];\r\n</pre><p>Simply scheduling the event-driven object (within your task) inside the current thread’s run loop isn’t enough. You have to tell the run loop when to start polling for events. This can be done with:</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [[NSRunLoop currentRunLoop] run];\r\n</pre><p>\r\n\tor</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [[NSRunLoop currentRunLoop] runMode:NSRunLoopCommonModes beforeDate:&lt;a Date&gt;];\r\n</pre><p>\r\n\tor</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [[NSRunLoop currentRunLoop] runUntilDate:&lt;a Date&gt;];\r\n</pre><p>Keep in mind that once you begin running the run loop, events/methods will only fire if they are included within the scope of that method call. Thus, if this portion of your task is written as:</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [runLoop \"run\" method call];\r\n[another method call];\r\n</pre><p>The following method will never get called while the run loop is running. Whereas if the task is written as:</p>\r\n<pre class=\"brush: objc; title: ; notranslate\" title=\"\"> [a local method call];\r\n[runLoop \"run\" method call];\r\n</pre><p>The method within the scope of the run loop’s “run” method call will be performed during the run loop’s duration. This is important if you wish to manually exit the thread via some kind of “time-out” mechanism (usually implemented through a timer, or “NSTimer”, in this case).</p><p>If implemented correctly you should be able to witness your application’s responsiveness during asynchronously-performed tasks (via the class’ delegate methods, or whatever “Observer” pattern you’ve implemented). Congratulations!</p><p>Be sure to check out Apple’s “<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html\">Threading Programming Guide</a>” for future reference, or if you have any issues.</p><p>As always, good luck with your implementation of multi-threaded design! Don’t hesitate to drop me a line if you have any comments or questions. See you next time!</p><p><em>Smashing Boxes is a web and mobile app development company know for creating a lasting experience through bold design and disrupting the status quo. We are entrepreneurs and craftsmen first, and a digital creative agency second. Inspired by our visionary clients, we transform ideas into innovative web and mobile applications. </em><a href=\"http://smashingboxes.com/work\">Take a look at our work.</a></p>",
  "slug": "the-power-of-run-loops-compels-you",
  "slug_history": "--- []\n",
  "visits": 8461,
  "published": "2014-01-23T05:00:00+00:00",
  "authorName": "Michael Brodeur ",
  "category_id": 4,
  "image_uid": "2014/07/29/12/09/21/876/file",
  "created_at": "2014-06-05T18:21:24+00:00",
  "updated_at": "2014-07-31T20:29:01+00:00",
  "markdown": null,
  "image_alt_text": null,
  "featured": false,
  "database_id": 232,
  "category": {
    "type": "Entry",
    "id": "category_4"
  },
  "tags": [
    {
      "type": "tag",
      "id": "tag_3"
    },
    {
      "type": "tag",
      "id": "tag_3"
    }
  ]
}